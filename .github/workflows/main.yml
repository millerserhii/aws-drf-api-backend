name: CI/CD Pipeline

on:
  push:
    branches:
      - main

env:
  TF_ROOT: ${{ github.workspace }}/terraform

jobs:
  setup:
    name: Setup Environment
    runs-on: ubuntu-latest
    environment: Staging
    steps:
      - name: Set up environment
        run: |
          echo AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }} >> $GITHUB_ENV
          echo AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }} >> $GITHUB_ENV
          echo AWS_REGION=${{ secrets.AWS_REGION }} >> $GITHUB_ENV
          echo ECR_REGISTRY=${{ secrets.ECR_REGISTRY }} >> $GITHUB_ENV
          echo ECR_REPOSITORY=${{ secrets.ECR_REPOSITORY }} >> $GITHUB_ENV

  test-sast:
    name: SAST
    runs-on: ubuntu-latest
    needs: setup
    steps:
      - name: Checkout Code
        uses: actions/checkout@v2
      - name: SAST Analysis
        run: |
          echo "Run SAST analysis"

#   terraform_plan:
#     name: Terraform Plan
#     runs-on: ubuntu-latest
#     environment: Staging
#     needs: setup
#     steps:
#         - name: Checkout code
#           uses: actions/checkout@v2

#         - name: Add terraform.tfvars
#           run: |
#             echo 'rds_db_name = "${{ secrets.RDS_DB_NAME }}"' >> $TF_ROOT/terraform.tfvars
#             echo 'rds_hostname = "${{ secrets.RDS_HOSTNAME }}"' >> $TF_ROOT/terraform.tfvars
#             echo 'rds_password = "${{ secrets.RDS_PASSWORD }}"' >> $TF_ROOT/terraform.tfvars
#             echo 'rds_port = "${{ secrets.RDS_PORT }}"' >> $TF_ROOT/terraform.tfvars
#             echo 'rds_username = "${{ secrets.RDS_USERNAME }}"' >> $TF_ROOT/terraform.tfvars
#             echo 'redis_endpoint = "${{ secrets.REDIS_ENDPOINT }}"' >> $TF_ROOT/terraform.tfvars
#             echo 'redis_password = "${{ secrets.REDIS_PASSWORD }}"' >> $TF_ROOT/terraform.tfvars
#             echo 'redis_user = "${{ secrets.REDIS_USER }}"' >> $TF_ROOT/terraform.tfvars
#             echo 'ecr_registry = "${{ secrets.ECR_REGISTRY }}"' >> $TF_ROOT/terraform.tfvars
#             echo 'ecr_repository = "${{ secrets.ECR_REPOSITORY }}"' >> $TF_ROOT/terraform.tfvars
#         - name: Set up AWS CLI
#           uses: aws-actions/configure-aws-credentials@v1
#           with:
#             aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
#             aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
#             aws-region: ${{ secrets.AWS_REGION }}
#         - name: Install Terraform
#           uses: hashicorp/setup-terraform@v1
#         - name: Terraform Init and Plan
#           run: |
#             cd $TF_ROOT
#             terraform init
#             terraform plan

#   terraform_apply:
#     name: Terraform Apply
#     runs-on: ubuntu-latest
#     needs: terraform_plan
#     environment: Staging
#     if: github.event_name == 'push'
#     steps:
#         - name: Checkout code
#           uses: actions/checkout@v2
#         - name: Set up AWS CLI
#           uses: aws-actions/configure-aws-credentials@v1
#           with:
#             aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
#             aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
#             aws-region: ${{ secrets.AWS_REGION }}
#         - name: Install Terraform
#           uses: hashicorp/setup-terraform@v1
#         - name: Terraform Init and Apply
#           run: |
#             cd $TF_ROOT
#             terraform init
#             terraform apply -auto-approve

  build-and-push:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    environment: Staging
    needs: [setup]
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v1
      - name: Log in to Amazon ECR
        run: |
          aws ecr-public get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $ECR_REGISTRY

      - name: Create .env file
        run: |
          echo DJANGO_CONFIGURATION=${{ vars.DJANGO_CONFIGURATION }} >> .env
          echo DJANGO_SETTINGS_MODULE=${{ vars.DJANGO_SETTINGS_MODULE }} >> .env
          echo DJANGO_SECRET_KEY=${{ secrets.DJANGO_SECRET_KEY }} >> .env
          echo RDS_DB_NAME=${{ secrets.RDS_DB_NAME }} >> .env
          echo RDS_HOSTNAME=${{ secrets.RDS_HOSTNAME }} >> .env
          echo RDS_PASSWORD=${{ secrets.RDS_PASSWORD }} >> .env
          echo RDS_PORT=${{ secrets.RDS_PORT }} >> .env
          echo RDS_USERNAME=${{ secrets.RDS_USERNAME }} >> .env
          echo REDIS_ENDPOINT=${{ secrets.REDIS_ENDPOINT }} >> .env
          echo REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }} >> .env
          echo REDIS_USER=${{ secrets.REDIS_USER }} >> .env
          echo ECR_REGISTRY=${{ secrets.ECR_REGISTRY }} >> .env
          echo ECR_REPOSITORY=${{ secrets.ECR_REPOSITORY }} >> .env
      - name: Build and Push Docker Image
        run: |
          docker build -t $ECR_REPOSITORY .
          docker tag $ECR_REPOSITORY:latest $ECR_REGISTRY/$ECR_REPOSITORY:latest
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

  deploy_to_ecs:
    name: Deploy to ECS
    runs-on: ubuntu-latest
    needs: build-and-push
    environment: Staging
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Set up AWS CLI
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
      - name: Install jq
        run: sudo apt-get install -y jq
      - name: Deploy to ECS
        env:
          NEW_IMAGE_URI: "${{ secrets.ECR_REGISTRY }}/${{ secrets.ECR_REPOSITORY }}:latest"
          TASK_FAMILY: "webapp-task"
          AWS_REGION: ${{ secrets.AWS_REGION }}
        run: |
          TASK_DEF_JSON=$(aws ecs describe-task-definition --task-definition $TASK_FAMILY | jq '.taskDefinition')
          NEW_TASK_DEF_JSON=$(echo $TASK_DEF_JSON | jq --arg IMAGE_URI "$NEW_IMAGE_URI" '. | .containerDefinitions[0].image = $IMAGE_URI | {family: .family, executionRoleArn: .executionRoleArn, networkMode: .networkMode, containerDefinitions: .containerDefinitions, volumes: .volumes, requiresCompatibilities: .requiresCompatibilities, cpu: .cpu, memory: .memory}')
          NEW_REVISION=$(aws ecs register-task-definition --cli-input-json "$NEW_TASK_DEF_JSON" | jq -r '.taskDefinition.taskDefinitionArn')
          aws
